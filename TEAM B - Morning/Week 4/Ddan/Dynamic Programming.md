# Dynamic Programming
Dynamic Programming이란 상향식 접근 방법으로, 가장 작은 부분의 해답을 구한 후 그 값을 저장하고, 그 값을 이용해서 상위의 문제를 푸는 방식이다.

여기서 중요한 부분은 '저장'을 통해 상위 문제를 해결한다는 점이다.

DP(Dynamic Programming)의 핵심은 Memoization이다. 동일한 계산을 반복해야할 때, 이전에 계산한 값을 이용해야할 때 주로 이용하며, 이 전에 계산한 값을 메모리에 저장하여 반복 수행을 제거하는 기법으로 이를 이용하면 메모리를 사용하지만 프로그램 실행 속도를 빠르게 할 수 있는 장점이 있다.

## 이해 돕기
확실히 글로 이렇게 보는 것보다 직접 예제를 보면서 이해하는 것이 쉬울 것 같다.

### Fibonacci _ using recursive function
피포나치 수열이란 
- 0,1,1,2,3,5,8,13...

이런 방법으로, 첫번째 두번째 0,1을 제외한 나머지는 앞의 값 두개를 더한 값으로 수열을 이어나가는 것이 피포나치 수열이다.

이 피보나치를 점화식으로 표현한다면 아래와 같다.

<img width="587" alt="image" src="https://github.com/eemdeeks/iOS/assets/87136217/4cb14e55-6e63-42eb-9ec0-9af1d4ec2537">

흔히 피포나치를 구현하라고 할 때 DP를 모른다면 그냥 재귀함수를 이용해서 구할 것이다.
Ex)
```swift
func fibo(_ n: Int) -> Int {
    if n<= 1 { return n}
    return fibo(n - 1) + fibo(n - 2)
}
```
이렇게 재귀함수를 이용하여 쉽게 구현할 것이다.

하지만 이렇게 재귀함수를 이용하여 구한다면 큰 값을 구할 때 쓸대 없이 많은 fibo함수를 호출하게 될것이다.

fibo(4)를 예시로 들자면
fibo(4)의 값을 얻기 위해
- fibo(0)을 2번
- fibo(1)을 3번
- fibo(2)를 2번

이렇게 중복하여 호출하게 된다. 

예시로 4를 들었지만 만약 엄청 큰 값의 n을 넣게 된다면 실행 속도가 매우 떨어지게 될것이다.

이럴 때 DP를 사용하게 된다면 이 점을 보완할 수 있다.

### Fibonacci _ using DP
위에서 말했듯이 DP는 메모이제이션을 사용한다.

가장 작은 단위부터 계산하는데, 이를 저장하여 사용한다고 했다. 이렇게 저장을 하기 위해서 저장 공간을 필요로 한다.

Ex)
```Swift
func fibo(_ n: Int) -> Int{
    var cache: [Int] = [0,1]
    
    for num in 2...n {
        cache.append(cache[num - 1] + cache[num - 2]
    }
    return cache[n]
}
```
DP를 이용하면 피보나치 수열을 구하는 코드를 이렇게 구현할 수 있다.

재귀함수를 사용할 때와 다르게 cache라는 메모리를 만들어 메모리 안의 값을 접근(한 값을 구할 때 딱 한번)하여 메모리를 채워나가는 형식으로 구현되었다.

이렇게 할 경우 재귀함수를 이용했을 때와 다른게 아무리 큰 값의 n이 들어오더라도 O(n)수준의 시간을 이용해서 구할 수 있어 실행 속도가 빨라지는 것을 확인 할 수 있다.

## 동적 계획법 vs 분할 정복
동적 계획법과 분할 정복은 공통점과 차이점으로 나눌 수 있다.

아직 분할 정복에 대해서 공부를 하지 않았기에 적당히 같은 점과 다른 점만 알아가보자.

### 공통점
- 문제를 잘게 쪼개서, 가장 작은 단위로 분할하여 문제를 해결

### 차이점
1. 동적 계획법
- 작은 단위로 쪼개진 문제들은, 상위 문제를 해결하는 데 재사용 됨.
- Memoization 기법 사용.

2. 분할 정복
- 작은 단위로 쪼개진 문제들은, 상위 문제를 해결하는 데 재사용되지 않음.
- Memoization 기법 사용하지 않음.

***
이제 문제를 풀러 가봅시다.

### 참고
- [개발자 소들이_티스토리블로그](https://babbab2.tistory.com/100)
